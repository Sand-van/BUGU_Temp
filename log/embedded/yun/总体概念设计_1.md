# 基础概念参考

**本参考将会尽量完整地描述所有我们需要实现的功能、概念或想法，在后续的实际设计中应尽量遵照此处的内容进行设计。**

**考虑到通过可视化界面进行编程和通过代码进行编程会有一定的出入，所以在此说明和记录一些概念以便后面交流方便。**

**我们在之前的研究学习中曾经定义过一些概念，如程序描述文件、模块等，这些概念有的仍会保留或作出一些修改，有的将会被替换成其它更加通俗或等价术语（如模块在之后将被称之为方法），所以尽管你可能已经对整体流程有非常熟悉的认识，但还是建议完整阅读本参考。**

**在本项目中，如果没有特殊说明，在使用以下词语时均表示后述解释的意思。**

---

- 用户：本平台关注的用户主要可以被分类为用户单位和用户团队，该区分有利于设计用户进行独立开发和团队开发时所需的不同操作，如果在绝大多数语境中使用用户一词，一般仅单指用户单位。
  
  - 用户单位：用户单位指使用本平台的单个用户，而不包含组织或团体。
  
  - 用户团队：用户团队特指多个用户单位为开发某一工程而组建的团体。
    
    - 工程：由用户单位或团队开发的某一较大目标任务，工程下属可以分为多个组件，每个工程下属有且必须有一个核心组件，核心组件仅可在工程中创建而不能单独创建。
    
    - 组件：由用户单位或团队开发的某一较小目标任务，组件可以单独存在，也可属于某一工程或被嵌套包含在其它组件中，但组件最终不能单独被解析为一个可被编译为可执行代码的程序，组件的本身应类似于C语言的函数库，不过无论是工程所属组件或单独组件应都可以被其它工程所调用来实现。
    
    - 项目：用于统称工程和组件，当一些概念中工程和组件相同时或没必要进行区分时，则将两者统称为项目。
    
    - *例如：某团队由多人组成，且均使用本平台工作，他们在使用本平台时是用户单位，而当这个团队决定合力开发一个蓝牙耳机时，他们可以创建一个蓝牙耳机工程，且所有人一起加入该工程，他们此时就成为了该工程的用户团队。在进行工程开发时，考虑到蓝牙耳机需要涉及蓝牙通信和音频播放两个部分，他们可以在该工程中分别建立蓝牙通信和音频播放两个组件并分别进行开发，之后通过整合两个组件形成完整的工程。此外，用户单位也可以在没有工程时自建组件，例如上例中，某用户单位可以自制蓝牙通信组件，若其将该组件分享，则其它需要使用该组件的用户团队可以获取该组件。*

- 用户界面：用户单位用于注册账号，管理用户团队、自己的项目等基础工作所需界面的总称。
  
  - 注册界面：用于用户进行注册账号，用户应该可以使用手机、邮箱进行注册，通过验证码完成注册。注册过程中需要填入昵称、密码信息，注册完成后将会获得唯一id号。
  
  - 团队管理：用户可以组建自己的用户团队或加入其它用户团队，普通用户在使用期间最多可以注册五个团队且每个团队不超过三个人（该限制为体现可收费化的处理，未来用户可以通过缴费或完成一些任务来解除限制），用户可加入团队的数量不限。用户可以管理自己团队的队员，包括加入和移出。用户团队可以建立项目，此时的项目将会被所有团队成员共同管理。
  
  - 工作空间：用户可以在工作空间管理自己个人的或所属团队的所有项目，个人的项目在未公开前只允许自己查看和编辑，但用户可以进行分享使更多人能够看到，关于分享界面的设计暂时还在设计中，目前希望参考git相关设计。
  
  - 其它界面：一些如设置、个人账户管理等内容，目前暂时作最简化处理即可，未来再根据实际需求进行扩充。

- 开发界面：用户除了可以使用用户界面进行管理，还可以使用开发界面进行开发。开发界面主要指用户单位在使用本平台进行可视化编程时，所需要使用到的所有界面的总称，目前主要包括：逻辑界面、数据界面。开发界面设计目前废除最初的面向对象语法和面向过程语法共存的思想，转为全面使用面向对象的思想。
  
  - 面向对象：面向对象思想具体定义请自行搜索学习，经考量本系统在进行开发时主要遵从面向对象的开发思想，全面提供针对面向对象开发的功能支持，仅在一定程度上根据需要（在设计实现过程中考量）保留面向过程的功能支持。因为此处概念在各种编成中应用广泛，故在遇到本条目说明的词语后，应当结合语境进行理解，如果出现文档无法理解的情况，请提交`issue`并说明情况。
    
    - 类、对象：设计过程中，应该尽量保证实现万物皆对象的设计理念，当然这个过程肯定会是漫长的，如果在设计过程中一时间无法实现此理念，可进行记录后等待未来进行改进。用户需要在数据界面设计类和定义对象，类和对象的内容包括了属性值和方法。理论上用户在定义任何属性或方法的时候，都应该首先声明其所属的类或对象，但是考虑到用户体验方便的原因，用户也应该可以直接定义属性或方法而不显示地声明其所属类或对象，此时这些属性或方法将会被可变更地隐式声明在一个大的对象中，该对象则归于一种专门的基类（具体内容还在设计中）
      
      - 基类：在面向对象思想中，任何派生类都应该所属与某一个基类，目前对基类的简单设想为设计一些基础基类用于基础语法的实现，同时设计多种扩展基类用于让用户自定义派生类。
      
      - 属性值：属性值本质上是对类和对象内部所属的变量和常量的总称，属性值在定义前应该总是声明其所属与哪一个类，否则其将被隐式声明到某一个基类对象中。
      
      - 方法：以传统C语言的概念出发，方法即为函数，但从面向对象的角度出发，每个方法的运行者应该是由某个具体对象来进行。在本平台中，包括传统的赋值语句、计算语句等，在逻辑界面进行的任何行为均应以方法的形式展示，尽管也许在部分传统代码语言中如C中它们如赋值语句属于基础语法而非函数，但此处他们都是方法。方法关于所属对象的要求与属性值相同，但未来考虑到会上系统，也可能增加一些其它特性。
        
        - 参数：同样类比传统C语言函数参数的概念，一些方法的运行需要参数，参数分为形式参数和实际参数。
          
          - 形式参数：简称形参，在方法定义时，形参列表可视为对若干数据的声明，这些参数此时为概念上存在，以方便方法定义时的语义表达。
          
          - 实际参数：简称实参，在调用方法时，编程者将多个真实存在的变量或常量按照数据类型依次填入方法的参数列表，从而实现数据的传递。
          
          - 值传递：仅将实参当前的值传递给方法内部，方法将在获取该值后在内部堆栈建立对应副本然后进行运行，运行中对副本的改变不会反映到原本传入的参数。此功能在C语言中已经实现，我们直接使用即可。
          
          - 引用传递：将实参的地址直接传递给方法，方法内部在对该参数进行处理的时候实际处理的就是传入的实参本身而非副本，运行中的改变将会反映到原本的实参中。此功能在C语言中通过指针进行实现，我们直接使用即可。此外，通过引用传递可以替代C中的返回值功能和多返回值功能。
          
          - 变参：即数量可变的参数列表或可变参数，一般在C语言中可以调用`stdarg.h`文件后使用`...`来实现，便于开发者在实际开发中调用一个函数时可以传入不定个数的参数来编程。目前本平台暂时不用实现该功能，但是未来开发到一定阶段后仍然需要思考如何将其实现。
          
          - 方法直接传值：这是一种代码编程中的语法糖，我们可以直接将一个函数或方法写在另一个函数或方法的实参列表中，将其返回值作为参数进行传递，考虑到便捷性该功能确实仍然有存在的必要，故我们需要设计一种在逻辑界面编程区也可以使用的类似语法功能，关于详细设计写在后面的逻辑界面编程区介绍中。
  
  - 逻辑界面：逻辑界面主要提供逻辑信息，以传统C语言的概念出发，逻辑界面主要功能类似于方法调用、赋值、计算等需要计算机执行的动作信息，我们将这些功能全部合并称之为方法。
    
    - 方法区：在方法区中，用户可以查看他目前可以调用的所有方法，所有方法按照一定的分类呈树状排列，方法区应该尽量简单清晰地展现如下内容：
      
      - id：任何出现在方法区的方法都应该至少拥有一个不会重复的唯一id，id由字母和数字共同组成，id的产生可类似于（作者账户id+【0】表示创建于某工程+工程id+【1】表示创建于某组件+组件id+本组件内所创建的方法顺序编号），当然也可以为其它方式，总之后端和嵌入式端始终可以快速通过id找到该方法的代码路径或生成方法。
      
      - 方法名称：中文名，由多个词语共同构成，以方便翻译，只需要翻译软件针对每个词语进行单独翻译即可而不用考虑短语翻译导致可能产生的歧义，在组件内部，始终不允许使用相同的方法名。
        
        - 命名规则：方法名称的命名规则与数据（常量、变量等）的命名规则类似，均以多个词语拼接的方式表示，且前n个词语（n根据实际选择有所变化）用户无法自定义而只能在其中进行选择，当选择完前n个词语后才可以继续添加一些内容进行补充说明，该设计除了便于理解、翻译等目的外，也可以用于在编成界面方法区进行分类。该设计尚未彻底完善，但在早期设计时就应该有所体现。
          
          - 官方定词：在用户进行方法或数据命名时由官方定下的一系列命名语，官方定词通过层级排列，选择好上级定词后用户只能从下级官方定词中继续选择该上级官方定词所属的下级官方定词。方法和数据拥有不完全相同的官方定词。关于官方定词的设计将在未来放置在preference文件夹中，该设计和方法区的分组相关。
          
          - 自定义定词：当官方定词给定的下级定词结束或允许自定义定词后，用户即可进行自定义定词，用户可以层级向下继续嵌套自定义定词，也可以保存一些定词结构作为模板使用。自定义定词虽然自定义且不限长度，但仍然鼓励用户尽量用词语嵌套而非短语或句子来命名。
          
          - 重载定词：重载定词依然属于自定义定词，但是重载定词需要单独点击按钮进行添加，重载定词可以满足让多个官方定词和自定义定词中非重载定词部分完全相同的方法合并在一起而不冲突，然后通过不同的重载定词将其分割为不同重载。
      
      - 方法模板：考虑到一些常用功能经常会有顺序地使用一组不同的方法，故我们可以设计方法模板。例如一个SPI主机通信，总是需要先初始化SPI功能并将其设置为主机，然后一般先使用SPI发送功能发送指令，然后使用SPI接收功能接收回答，并如此往复，为此我们可以添加一个SPI主机通信方法模板，使用该模板后就无需再在方法列表中寻找SPI的各种方法，而只需要在该模板中寻找即可。此功能的存在同时有利于帮助方法作者告知用户这些方法该如何使用，首先用什么，然后用什么。
      
      - 功能简介：使用一句话介绍该功能，因为通过方法名称的分类，方法功能已经非常清晰了，所以一句话来说明功能是足够的。
      
      - 重载类型：根据硬件的实际需求，相同功能在实现的时候我们可能需要不同的实现，例如在一个有UART硬件的芯片和一个没有UART硬件的芯片之间，实现UART通信的方法过程是不尽相同的。同一个方法可以拥有多个不同的重载类型，同一方法的不同重载类型实际上是不同的方法，他们拥有不同的id、功能简介，但是他们的方法名称的非重载定词部分是相同的，通过重载定词进行区别。
    
    - 编程区：当用户在方法区选择好了自己所需的方法后，即可将其添加至编程区，编程区将添加的方法从上到下依次放置。此时方法以更加丰富的类似卡片的形式进行展示，通过点击方法卡片可以查看方法的更加详细信息。
      
      - 方法名称：内容规则等同上介绍，在编程区无论是否展开卡片，均应显示方法名称。
      
      - 参数列表：参数列表用于记录该方法与外部的数据交互，此功能在本平台中我们参考python的语法概念以及一些个人设计，我们将参数分为两种基础类型，输入和输出，两种类型以列表形式展示且均可以为多个。同时输入参数可以被定为引用传入（同C的引用传递）或副本传入（同C的值传递）（这里两种命名只是为了更加便于非专业用户更快更好理解，但使用引用传递和值传递的说法也是正确的）。在实际解析中，所有输出均通过指针参数的方式进行解析，同时引用传入的输入参数会被默认同时拥有输出参数的特性并被以指针参数的方式进行解析，副本传入则按照正常参数的方式进行传递（哪怕其因为是个指针而使用了指针参数，但是在概念里我们仍将其称之为值传递，且考虑到用户理解和尽量减少指针使用以防止出错的思想，我们应尽量使用一些特殊的规则将这些问题解决，例如原本传递数组无论如何我们只能使用引用传递且最终结果注定将影响，但实际操作中我们可以针对如此的内容在解析时调用内存分配为该数组创建副本然后使用副本进行工作，这里的设计可能有点麻烦，目前设计方案暂时先仍然定为以指针的方式传入，但保留此处的设计想法。），在解析结果中我们放弃返回值统一使用void，所有返回值均通过输出参数的方式进行解析实现。
        
        - 填写参数：调用方法后必须填写所有的输入参数列表，输入参数列表的内容来自数据界面已定以的变量或常量，若需要使用未定义的内容，我们应该有快捷方式进行快速定义。
        - 方法直接传值：即通过其它方法的输出参数直接传入到本方法的输入参数，该功能在解析为C语言时根据用户想要作为传递的输出参数是否为引用传递进行设计，如果为引用传递，则必然存在一个用户自定义的变量，我们只需要使用该变量在上一个方法运行完毕后直接将该变量作为参数传递给新的方法即可（前提是类型相同，否则需要实现强制转换），如果不是引用传递，则解析系统自动申请地址并malloc一个临时变量，然后将数据传递给此变量，由此变量代替传递给需要参数的方法。在前端我们以卡片的形式缩进展示（或通过线条连接排布等方式进行展示），对于需要输入参数的方法，我们需要标明此时方法直接传值的方法是对应的哪一个参数，对于提供输出参数的方法，我们需要标明其使用的哪一个参数进行传值，上述两个标注前者因为考虑到一个方法的多个输入参数都可以被其它方法进行传入，故使用结构的方法进行标明，后者则因为只需要一个输出标明故可以使用颜色直接体现。此外，这里的设计无论是前端还是嵌入式都需要注意这种传值方法是允许嵌套的。
        - 默认参数：本设计参考了C++的默认值设计，考虑到一些设计中方法作者认为绝大多数情况下该方法的某参数都可以直接使用某个值，但是为了提供可迁移性更强的代码，该参数最终仍然需要将接口暴露。这种设计尽管提高了代码的可移植性，但同时也提高了代码出错的风险。故此我们可以设计默认参数的设计来让方法作者可以给出一些更加明确的默认限定，方法在被添加到编程区后会立刻初始拥有默认值，如果用户不进行修改直接使用并不会报错，且会默认直接使用该默认值（注意，如果方法作者没有添加默认参数，则始终不应该为其自动添加参数，同时默认参数的显示效果不能和普通参数一样，以便让用户始终明白该参数为默认参数而非自己添加的参数，可以用如勾选开关的方式标注此时参数的内容为默认参数还是用户自定义参数）默认参数应有以下几种：
          - 单值：方法作者可以使用单个固定值作为默认参数，此时默认参数将只会显示该值。
          - 多值：方法作者可以使用多个固定值作为默认参数，并在这些值中选择一个作为显示，用户可以通过下拉列表的方式选择不同的值。
          - 区间：方法作者可以为参数限定区间，并在该区间取一个值作为直接显示的默认值，此时使用者可以在该区间中选取其它值填入作为默认值的变值。区间可以为单一的连续区间，也可以是多个不连续的区间，如果为多个不连续区间，则应该提供下拉列表选择不同区间，用户在此时填入的值不应该超出区间范围，前端应该注意检测。
        - 重载：在逻辑区的方法应该拥有一个快捷方式将其替换为该方法的其它对应重载。重载的存在除了便于用户更方便地编程，同时也有利于我们嵌入式端实现不同芯片间的快速代码移植。根据HAL思想，我们可以为一些基础功能设置重载，不同芯片针对这些基础功能所调用的底层代码有所不同，然后在移植时我们只需要将这些基础功能的重载进行替换即可。除此之外，重载的参数也应该可以设置对应关系，这样在移植时替换重载可以不用替换所有参数，以此实现更加方便的移植。
      
      - 自定义方法：用户可以进行自定义方法，并可设计多层命名定词进行分组，自定义出的方法应该可以在方法区看见，自定义方法的时候应该进入到一个新的编程界面进行定义。
        
        - 核心方法：用户如果创建了工程，则会拥有一个核心组件，而核心组件中会拥有一个核心方法。核心方法的存在等同于其它语言的main函数，其存在形式和普通自定义方法相同，但是其参数列表固定，具体内容遵照C语言规范，一个整形输出，一个整形输入，一个字符串数组输入。
        
        - 普通方法：除了核心方法，其它任何方法均为普通方法，需要用户自定义设计参数列表。包括核心方法在内，所有方法定义的时候，都会使用一个方法定义方法，然后所有操作均在该方法内部进行。
        
        - 语法方法：除此之外，我们还有一些基础方法，他们不是核心方法，也不是被用户自定义的普通方法（哪怕我们针对芯片定义的一些基础功能方法，其本质也是普通方法），这些方法的作用为提供一些基础语法供用户使用，这些方法的显示效果应有别于其它方法，以合适的方式进行显示。
          
          - 方法定义方法：一种属于语法类的方法，因为我们在逻辑区的一切操作均为方法，故定义方法也是一种方法，但是这种方法是一种语法，我们在该方法中输入的参数内容就是定义出的方法的方法列表。任何一个单独的编程界面最多只能拥有一个方法定义方法，即如果需要定义一种新的方法，都需要进入到一个新的编程界面。除了方法定义方法本身，任何其它方法均只能放置在方法定义方法内部。方法定义方法会形成一个结构上的改变（例如缩进），表示其后的内容全部在方法定义方法中。
          
          - 运行结束方法：即return语句，不过同样也是方法，运行结束方法会以return的形式存在。运行结束方法本身并没有任何参数，但编译系统需要检测在运行结束方法之前是否所有输出参数都进行了至少一次赋值（包括引用传递的参数），如没有则会报错。
          
          - 赋值方法：即赋值语句，通过该方法可以实现值传递，同时考虑到一般赋值时会进行一些计算，故赋值方法中应该可以嵌套计算方法，同时本身也会提供一些基础的运算符号，让用户以类似计算器一样的书写方式得到反馈（此部分设计需要更加详细的设计）。
          
          - 分支方法：即判断语句，以C语言的设计判断语句分为if和switch，我们同样保留这样的设计，因为if更加通用而switch速度更快。故分支方法分为顺序分支（if）和条件分支（switch）（此处命名尚未确定，暂时这样称呼），顺序分支方法的参数为一个判断语句，在进行了一次判断后通过点击新增按钮可以在下放添加一个新的顺序分支。而条件分支由初始化方法和分支方法组成，初始化方法的参数为一个输入参数，在填入了输入参数后可以点击添加按钮将会新增分支方法，然后新增的分支会方法的参数将会是一个填入的参数同类型的输入参数，且输入参数只能填写常量（因为考虑到C语言中switch只能使用整数或字符，故本平台暂时先同样遵照C语言的语法，但未来应该想办法增设关于字符串的switch语法）。关于分支方法的分支显示，应该注意使用户易于分辨分支，同时还应该尽量提供显示合并的功能（即可以将分支内部的内容合并只显示分支整体或展开显示每个分支内部的程序细节，以便于查看整体和局部）
          
          - 循环方法：即循环语句，以C语言的设计循环语句分为for和while，我们保留这种设计但同时支持采用类似python、C#的迭代器设计，不过目前考虑到水平我们暂时只设计关于字符串和整数的迭代，而不涉及其它数据类型。使用迭代器时，使用一个对象作为存储值，然后依次遍历某个对象（也可以直接选择一个数字区间进行整数遍历），迭代对象除了记录值外还应该记录当前迭代次数等。
      
      - 注释内容：根据实际需求，我们应该可以在很多地方添加注释，包括但不限于每个方法，每个参数等。具体设计等后续再完善。
      
      - 其它功能：除了上述的功能外，我们还会拥有一些额外的小功能用于辅助设计，这些功能不会直接对编程结果造成影响，但是可以简化编程的难度。
        
        - 折叠器：我们可以为一组顺序的方法添加折叠器，此时我们可以将这一组方法折叠起来只显示折叠器的注释，当用户需要查看详细内容时再展开。以此简化编程界面。
        
        - 方法宏：我们可以将一系列方法组成一个方法宏，在未来我们只需要调用该方法宏，就可以直接将这一系列的方法添加到上面，该功能可以和折叠器一起使用。同时我们可以单独管理方法宏，为这些方法宏中的方法部分添加上参数，以实现更加灵活的编程效果。
        
        - 命令栏：通过命令栏，我们可以实现一些直接使用键盘而不用鼠标就可以完成的功能，这些功能包括添加方法等。为此我们需要设计一套适合我们平台的命令系统。
  
  - 数据界面：数据界面主要提供数据信息，以传统C语言的概念出发，数据界面主要功能类似于管理常量、变量或自定义数据类型等计算机执行动作时所需的参数信息。
    
    - 目前关于数据界面的设计尚在思考中，未来再继续进行添加。
  
  - 分享界面：类似github一样的项目分享界面，用户可以非常便利地将程序分享在上面，同时其他人也可以很方便地使用它。
    
    - 目前关于分享界面的设计尚在思考中，未来再继续进行添加。
